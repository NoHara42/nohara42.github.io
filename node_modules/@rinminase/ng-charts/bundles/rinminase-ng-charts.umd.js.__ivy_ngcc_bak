(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('chart.js'), require('rxjs'), require('lodash-es')) :
    typeof define === 'function' && define.amd ? define('@rinminase/ng-charts', ['exports', '@angular/core', 'chart.js', 'rxjs', 'lodash-es'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.rinminase = global.rinminase || {}, global.rinminase['ng-charts'] = {}), global.ng.core, global.chart_js, global.rxjs, global._));
}(this, (function (exports, i0, chartJs, rxjs, lodashEs) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var defaultColors = [
        [255, 99, 132],
        [54, 162, 235],
        [255, 206, 86],
        [231, 233, 237],
        [75, 192, 192],
        [151, 187, 205],
        [220, 220, 220],
        [247, 70, 74],
        [70, 191, 189],
        [253, 180, 92],
        [148, 159, 177],
        [77, 83, 96],
    ];

    /**
     * Generate colors by chart type
     */
    function getColors(chartType, index, count) {
        if (chartType === "pie" || chartType === "doughnut") {
            return formatPieColors(generateColors(count));
        }
        if (chartType === "polarArea") {
            return formatPolarAreaColors(generateColors(count));
        }
        if (chartType === "line" || chartType === "radar") {
            return formatLineColor(generateColor(index));
        }
        if (chartType === "bar" || chartType === "horizontalBar") {
            return formatBarColor(generateColor(index));
        }
        if (chartType === "bubble") {
            return formatPieColors(generateColors(count));
        }
        if (chartType === "scatter") {
            return formatPieColors(generateColors(count));
        }
        throw new Error("getColors - Unsupported chart type " + chartType);
    }
    function rgba(colour, alpha) {
        return "rgba(" + colour.concat(alpha).join(",") + ")";
    }
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function formatLineColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.4),
            borderColor: rgba(colors, 1),
            pointBackgroundColor: rgba(colors, 1),
            pointBorderColor: "#fff",
            pointHoverBackgroundColor: "#fff",
            pointHoverBorderColor: rgba(colors, 0.8),
        };
    }
    function formatBarColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.6),
            borderColor: rgba(colors, 1),
            hoverBackgroundColor: rgba(colors, 0.8),
            hoverBorderColor: rgba(colors, 1),
        };
    }
    function formatPieColors(colors) {
        return {
            backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),
            borderColor: colors.map(function () { return "#fff"; }),
            pointBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
            pointBorderColor: colors.map(function () { return "#fff"; }),
            pointHoverBackgroundColor: colors.map(function (color) { return rgba(color, 1); }),
            pointHoverBorderColor: colors.map(function (color) { return rgba(color, 1); }),
        };
    }
    function formatPolarAreaColors(colors) {
        return {
            backgroundColor: colors.map(function (color) { return rgba(color, 0.6); }),
            borderColor: colors.map(function (color) { return rgba(color, 1); }),
            hoverBackgroundColor: colors.map(function (color) { return rgba(color, 0.8); }),
            hoverBorderColor: colors.map(function (color) { return rgba(color, 1); }),
        };
    }
    function getRandomColor() {
        return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
    }
    /**
     * Generate colors for line|bar charts
     */
    function generateColor(index) {
        return defaultColors[index] || getRandomColor();
    }
    /**
     * Generate colors for pie|doughnut charts
     */
    function generateColors(count) {
        var colorsArr = new Array(count);
        for (var i = 0; i < count; i++) {
            colorsArr[i] = defaultColors[i] || getRandomColor();
        }
        return colorsArr;
    }

    var ThemeService = /** @class */ (function () {
        function ThemeService() {
            this.pColorschemesOptions = {};
            this.colorschemesOptions = new rxjs.BehaviorSubject({});
        }
        ThemeService.prototype.setColorschemesOptions = function (options) {
            this.pColorschemesOptions = options;
            this.colorschemesOptions.next(options);
        };
        ThemeService.prototype.getColorschemesOptions = function () {
            return this.pColorschemesOptions;
        };
        return ThemeService;
    }());
    ThemeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });
    ThemeService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: "root" },] }
    ];
    ThemeService.ctorParameters = function () { return []; };

    var UpdateType;
    (function (UpdateType) {
        UpdateType[UpdateType["Default"] = 0] = "Default";
        UpdateType[UpdateType["Update"] = 1] = "Update";
        UpdateType[UpdateType["Refresh"] = 2] = "Refresh";
    })(UpdateType || (UpdateType = {}));
    var BaseChartDirective = /** @class */ (function () {
        function BaseChartDirective(element, themeService) {
            this.element = element;
            this.themeService = themeService;
            this.options = {};
            this.chartClick = new i0.EventEmitter();
            this.chartHover = new i0.EventEmitter();
            this.old = {
                dataExists: false,
                dataLength: 0,
                datasetsExists: false,
                datasetsLength: 0,
                datasetsDataObjects: [],
                datasetsDataLengths: [],
                colorsExists: false,
                colors: [],
                labelsExist: false,
                labels: [],
                legendExists: false,
                legend: {},
            };
            this.subs = [];
        }
        /**
         * Register a plugin.
         */
        BaseChartDirective.registerPlugin = function (plugin) {
            chartJs.Chart.plugins.register(plugin);
        };
        BaseChartDirective.unregisterPlugin = function (plugin) {
            chartJs.Chart.plugins.unregister(plugin);
        };
        BaseChartDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.ctx = this.element.nativeElement.getContext("2d");
            this.refresh();
            this.subs.push(this.themeService.colorschemesOptions.subscribe(function () { return _this.themeChanged(); }));
        };
        BaseChartDirective.prototype.themeChanged = function () {
            this.refresh();
        };
        BaseChartDirective.prototype.ngDoCheck = function () {
            var _this = this;
            if (!this.chart) {
                return;
            }
            var updateRequired = UpdateType.Default;
            var wantUpdate = function (x) {
                updateRequired = x > updateRequired ? x : updateRequired;
            };
            if (!!this.data !== this.old.dataExists) {
                this.propagateDataToDatasets(this.data);
                this.old.dataExists = !!this.data;
                wantUpdate(UpdateType.Update);
            }
            if (this.data && this.data.length !== this.old.dataLength) {
                this.old.dataLength = (this.data && this.data.length) || 0;
                wantUpdate(UpdateType.Update);
            }
            if (!!this.datasets !== this.old.datasetsExists) {
                this.old.datasetsExists = !!this.datasets;
                wantUpdate(UpdateType.Update);
            }
            if (this.datasets && this.datasets.length !== this.old.datasetsLength) {
                this.old.datasetsLength = (this.datasets && this.datasets.length) || 0;
                wantUpdate(UpdateType.Update);
            }
            if (this.datasets &&
                this.datasets.filter(function (x, i) { return x.data !== _this.old.datasetsDataObjects[i]; })
                    .length) {
                this.old.datasetsDataObjects = this.datasets.map(function (x) { return x.data; });
                wantUpdate(UpdateType.Update);
            }
            if (this.datasets &&
                this.datasets.filter(function (x, i) { return x.data.length !== _this.old.datasetsDataLengths[i]; }).length) {
                this.old.datasetsDataLengths = this.datasets.map(function (x) { return x.data.length; });
                wantUpdate(UpdateType.Update);
            }
            if (!!this.colors !== this.old.colorsExists) {
                this.old.colorsExists = !!this.colors;
                this.updateColors();
                wantUpdate(UpdateType.Update);
            }
            // This smells of inefficiency, might need to revisit this
            if (this.colors &&
                this.colors.filter(function (x, i) { return !_this.colorsEqual(x, _this.old.colors[i]); })
                    .length) {
                this.old.colors = this.colors.map(function (x) { return _this.copyColor(x); });
                this.updateColors();
                wantUpdate(UpdateType.Update);
            }
            if (!!this.labels !== this.old.labelsExist) {
                this.old.labelsExist = !!this.labels;
                wantUpdate(UpdateType.Update);
            }
            if (this.labels &&
                this.labels.filter(function (x, i) { return !_this.labelsEqual(x, _this.old.labels[i]); })
                    .length) {
                this.old.labels = this.labels.map(function (x) { return _this.copyLabel(x); });
                wantUpdate(UpdateType.Update);
            }
            if (!!this.options.legend !== this.old.legendExists) {
                this.old.legendExists = !!this.options.legend;
                wantUpdate(UpdateType.Refresh);
            }
            if (this.options.legend &&
                this.options.legend.position !== this.old.legend.position) {
                this.old.legend.position = this.options.legend.position;
                wantUpdate(UpdateType.Refresh);
            }
            switch (updateRequired) {
                case UpdateType.Default:
                    break;
                case UpdateType.Update:
                    this.update();
                    break;
                case UpdateType.Refresh:
                    this.refresh();
                    break;
            }
        };
        BaseChartDirective.prototype.copyLabel = function (a) {
            if (Array.isArray(a)) {
                return __spread(a);
            }
            return a;
        };
        BaseChartDirective.prototype.labelsEqual = function (a, b) {
            return (true &&
                Array.isArray(a) === Array.isArray(b) &&
                (Array.isArray(a) || a === b) &&
                (!Array.isArray(a) || a.length === b.length) &&
                (!Array.isArray(a) || a.filter(function (x, i) { return x !== b[i]; }).length === 0));
        };
        BaseChartDirective.prototype.copyColor = function (a) {
            var rc = {
                backgroundColor: a.backgroundColor,
                borderWidth: a.borderWidth,
                borderColor: a.borderColor,
                borderCapStyle: a.borderCapStyle,
                borderDash: a.borderDash,
                borderDashOffset: a.borderDashOffset,
                borderJoinStyle: a.borderJoinStyle,
                pointBorderColor: a.pointBorderColor,
                pointBackgroundColor: a.pointBackgroundColor,
                pointBorderWidth: a.pointBorderWidth,
                pointRadius: a.pointRadius,
                pointHoverRadius: a.pointHoverRadius,
                pointHitRadius: a.pointHitRadius,
                pointHoverBackgroundColor: a.pointHoverBackgroundColor,
                pointHoverBorderColor: a.pointHoverBorderColor,
                pointHoverBorderWidth: a.pointHoverBorderWidth,
                pointStyle: a.pointStyle,
                hoverBackgroundColor: a.hoverBackgroundColor,
                hoverBorderColor: a.hoverBorderColor,
                hoverBorderWidth: a.hoverBorderWidth,
            };
            return rc;
        };
        BaseChartDirective.prototype.colorsEqual = function (a, b) {
            if (!a !== !b) {
                return false;
            }
            return (!a ||
                (true &&
                    a.backgroundColor === b.backgroundColor &&
                    a.borderWidth === b.borderWidth &&
                    a.borderColor === b.borderColor &&
                    a.borderCapStyle === b.borderCapStyle &&
                    a.borderDash === b.borderDash &&
                    a.borderDashOffset === b.borderDashOffset &&
                    a.borderJoinStyle === b.borderJoinStyle &&
                    a.pointBorderColor === b.pointBorderColor &&
                    a.pointBackgroundColor === b.pointBackgroundColor &&
                    a.pointBorderWidth === b.pointBorderWidth &&
                    a.pointRadius === b.pointRadius &&
                    a.pointHoverRadius === b.pointHoverRadius &&
                    a.pointHitRadius === b.pointHitRadius &&
                    a.pointHoverBackgroundColor === b.pointHoverBackgroundColor &&
                    a.pointHoverBorderColor === b.pointHoverBorderColor &&
                    a.pointHoverBorderWidth === b.pointHoverBorderWidth &&
                    a.pointStyle === b.pointStyle &&
                    a.hoverBackgroundColor === b.hoverBackgroundColor &&
                    a.hoverBorderColor === b.hoverBorderColor &&
                    a.hoverBorderWidth === b.hoverBorderWidth));
        };
        BaseChartDirective.prototype.updateColors = function () {
            var _this = this;
            this.datasets.forEach(function (elm, index) {
                if (_this.colors && _this.colors[index]) {
                    Object.assign(elm, _this.colors[index]);
                }
                else {
                    Object.assign(elm, getColors(_this.chartType, index, elm.data.length), Object.assign({}, elm));
                }
            });
        };
        BaseChartDirective.prototype.ngOnChanges = function (changes) {
            var updateRequired = UpdateType.Default;
            var wantUpdate = function (x) {
                updateRequired = x > updateRequired ? x : updateRequired;
            };
            // Check if the changes are in the data or datasets or labels or legend
            if (changes.hasOwnProperty("data") && changes.data.currentValue) {
                this.propagateDataToDatasets(changes.data.currentValue);
                wantUpdate(UpdateType.Update);
            }
            if (changes.hasOwnProperty("datasets") && changes.datasets.currentValue) {
                this.propagateDatasetsToData(changes.datasets.currentValue);
                wantUpdate(UpdateType.Update);
            }
            if (changes.hasOwnProperty("labels")) {
                if (this.chart) {
                    this.chart.data.labels = changes.labels.currentValue;
                }
                wantUpdate(UpdateType.Update);
            }
            if (changes.hasOwnProperty("legend")) {
                if (this.chart) {
                    this.chart.config.options.legend.display = changes.legend.currentValue;
                    this.chart.generateLegend();
                }
                wantUpdate(UpdateType.Update);
            }
            if (changes.hasOwnProperty("options")) {
                wantUpdate(UpdateType.Refresh);
            }
            switch (updateRequired) {
                case UpdateType.Update:
                    this.update();
                    break;
                case UpdateType.Refresh:
                case UpdateType.Default:
                    this.refresh();
                    break;
            }
        };
        BaseChartDirective.prototype.ngOnDestroy = function () {
            if (this.chart) {
                this.chart.destroy();
                this.chart = void 0;
            }
            this.subs.forEach(function (x) { return x.unsubscribe(); });
        };
        BaseChartDirective.prototype.update = function (duration) {
            if (this.chart) {
                return this.chart.update(duration);
            }
            return null;
        };
        BaseChartDirective.prototype.hideDataset = function (index, hidden) {
            this.chart.getDatasetMeta(index).hidden = hidden;
            this.chart.update();
        };
        BaseChartDirective.prototype.isDatasetHidden = function (index) {
            return this.chart.getDatasetMeta(index).hidden;
        };
        BaseChartDirective.prototype.toBase64Image = function () {
            return this.chart.toBase64Image();
        };
        BaseChartDirective.prototype.getChartConfiguration = function () {
            var _this = this;
            var datasets = this.getDatasets();
            var options = Object.assign({}, this.options);
            if (this.legend === false) {
                options.legend = { display: false };
            }
            // hook for onHover and onClick events
            options.hover = options.hover || {};
            if (!options.hover.onHover) {
                options.hover.onHover = function (event, active) {
                    if (active && !active.length) {
                        return;
                    }
                    _this.chartHover.emit({ event: event, active: active });
                };
            }
            if (!options.onClick) {
                options.onClick = function (event, active) {
                    _this.chartClick.emit({ event: event, active: active });
                };
            }
            var mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
            var chartConfig = {
                type: this.chartType,
                data: {
                    labels: this.labels || [],
                    datasets: datasets,
                },
                plugins: this.plugins,
                options: mergedOptions,
            };
            return chartConfig;
        };
        BaseChartDirective.prototype.getChartBuilder = function (ctx /*, data:any[], options:any*/) {
            var chartConfig = this.getChartConfiguration();
            return new chartJs.Chart(ctx, chartConfig);
        };
        BaseChartDirective.prototype.smartMerge = function (options, overrides, level) {
            var _this = this;
            if (level === void 0) { level = 0; }
            if (level === 0) {
                options = lodashEs.cloneDeep(options);
            }
            var keysToUpdate = Object.keys(overrides);
            keysToUpdate.forEach(function (key) {
                if (Array.isArray(overrides[key])) {
                    var arrayElements = options[key];
                    if (arrayElements) {
                        arrayElements.forEach(function (r) {
                            _this.smartMerge(r, overrides[key][0], level + 1);
                        });
                    }
                }
                else if (typeof overrides[key] === "object") {
                    if (!(key in options)) {
                        options[key] = {};
                    }
                    _this.smartMerge(options[key], overrides[key], level + 1);
                }
                else {
                    options[key] = overrides[key];
                }
            });
            if (level === 0) {
                return options;
            }
        };
        BaseChartDirective.prototype.isMultiLineLabel = function (label) {
            return Array.isArray(label);
        };
        BaseChartDirective.prototype.joinLabel = function (label) {
            if (!label) {
                return null;
            }
            if (this.isMultiLineLabel(label)) {
                return label.join(" ");
            }
            else {
                return label;
            }
        };
        BaseChartDirective.prototype.propagateDatasetsToData = function (datasets) {
            this.data = this.datasets.map(function (r) { return r.data; });
            if (this.chart) {
                this.chart.data.datasets = datasets;
            }
            this.updateColors();
        };
        BaseChartDirective.prototype.propagateDataToDatasets = function (newDataValues) {
            var _this = this;
            if (this.isMultiDataSet(newDataValues)) {
                if (this.datasets && newDataValues.length === this.datasets.length) {
                    this.datasets.forEach(function (dataset, i) {
                        dataset.data = newDataValues[i];
                    });
                }
                else {
                    this.datasets = newDataValues.map(function (data, index) {
                        return {
                            data: data,
                            label: _this.joinLabel(_this.labels[index]) || "Label " + index,
                        };
                    });
                    if (this.chart) {
                        this.chart.data.datasets = this.datasets;
                    }
                }
            }
            else {
                if (!this.datasets) {
                    this.datasets = [{ data: newDataValues }];
                    if (this.chart) {
                        this.chart.data.datasets = this.datasets;
                    }
                }
                else {
                    this.datasets[0].data = newDataValues;
                    this.datasets.splice(1); // Remove all elements but the first
                }
            }
            this.updateColors();
        };
        BaseChartDirective.prototype.isMultiDataSet = function (data) {
            return Array.isArray(data[0]);
        };
        BaseChartDirective.prototype.getDatasets = function () {
            if (!this.datasets && !this.data) {
                throw new Error("ng-charts configuration error, data or datasets field are required to render chart " + this.chartType);
            }
            // If `datasets` is defined, use it over the `data` property.
            if (this.datasets) {
                this.propagateDatasetsToData(this.datasets);
                return this.datasets;
            }
            if (this.data) {
                this.propagateDataToDatasets(this.data);
                return this.datasets;
            }
            return null;
        };
        BaseChartDirective.prototype.refresh = function () {
            // if (this.options && this.options.responsive) {
            //   setTimeout(() => this.refresh(), 50);
            // }
            // todo: remove this line, it is producing flickering
            if (this.chart) {
                this.chart.destroy();
                this.chart = void 0;
            }
            if (this.ctx) {
                this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
            }
        };
        return BaseChartDirective;
    }());
    BaseChartDirective.decorators = [
        { type: i0.Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: "canvas[baseChart]",
                    exportAs: "base-chart",
                },] }
    ];
    BaseChartDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ThemeService }
    ]; };
    BaseChartDirective.propDecorators = {
        data: [{ type: i0.Input }],
        datasets: [{ type: i0.Input }],
        labels: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        chartType: [{ type: i0.Input }],
        colors: [{ type: i0.Input }],
        legend: [{ type: i0.Input }],
        plugins: [{ type: i0.Input }],
        chartClick: [{ type: i0.Output }],
        chartHover: [{ type: i0.Output }]
    };

    var ChartsModule = /** @class */ (function () {
        function ChartsModule() {
        }
        return ChartsModule;
    }());
    ChartsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [BaseChartDirective],
                    imports: [],
                    exports: [BaseChartDirective],
                },] }
    ];

    function monkeyPatchChartJsLegend() {
        if (typeof Chart === "undefined") {
            console.log("Chart not defined");
            return;
        }
        var plugins = Chart.plugins.getAll();
        var legend = plugins.filter(function (p) { return p.id === "legend"; })[0];
        legend._element.prototype.fit = fit;
        legend._element.prototype.draw = draw;
        var helpers = Chart.helpers;
        var defaults = Chart.defaults;
        var valueOrDefault = helpers.valueOrDefault;
        function getBoxWidth(labelOpts, fontSize) {
            return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize
                ? fontSize
                : labelOpts.boxWidth;
        }
        function fit() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me.ctx;
            var labelFont = helpers.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            // Reset hit boxes
            var hitboxes = (me.legendHitBoxes = []);
            var minSize = me.minSize;
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
                minSize.width = me.maxWidth; // fill all the width
                minSize.height = display ? 10 : 0;
            }
            else {
                minSize.width = display ? 10 : 0;
                minSize.height = me.maxHeight; // fill all the height
            }
            var getMaxLineWidth = function (textLines) {
                return textLines
                    .map(function (textLine) {
                    return ctx.measureText(textLine).width;
                })
                    .reduce(function (acc, v) {
                    return v > acc ? v : acc;
                }, 0);
            };
            // Increase sizes here
            if (display) {
                ctx.font = labelFont.string;
                if (isHorizontal) {
                    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
                    var lineWidths_1 = (me.lineWidths = [0]);
                    var lineHeights_1 = (me.lineHeights = []);
                    var currentLineHeight_1 = 0;
                    var lineIndex_1 = 0;
                    ctx.textAlign = "left";
                    ctx.textBaseline = "top";
                    helpers.each(me.legendItems, function (legendItem, i) {
                        var width, height;
                        if (helpers.isArray(legendItem.text)) {
                            width = getMaxLineWidth(legendItem.text);
                            height = fontSize * legendItem.text.length + labelOpts.padding;
                        }
                        else {
                            width = ctx.measureText(legendItem.text).width;
                            height = fontSize + labelOpts.padding;
                        }
                        width += getBoxWidth(labelOpts, fontSize) + fontSize / 2;
                        if (lineWidths_1[lineWidths_1.length - 1] + width + 2 * labelOpts.padding >
                            minSize.width) {
                            lineHeights_1.push(currentLineHeight_1);
                            currentLineHeight_1 = 0;
                            lineWidths_1[lineWidths_1.length - (i > 0 ? 0 : 1)] = 0;
                            lineIndex_1++;
                        }
                        legendItem.lineOrColumnIndex = lineIndex_1;
                        if (height > currentLineHeight_1) {
                            currentLineHeight_1 = height;
                        }
                        // Store the hitbox width and height here. Final position will be updated in `draw`
                        hitboxes[i] = {
                            left: 0,
                            top: 0,
                            width: width,
                            height: height,
                        };
                        lineWidths_1[lineWidths_1.length - 1] += width + labelOpts.padding;
                    });
                    lineHeights_1.push(currentLineHeight_1);
                    minSize.height += lineHeights_1.reduce(function (acc, v) {
                        return acc + v;
                    }, 0);
                }
                else {
                    var vPadding_1 = labelOpts.padding;
                    var columnWidths_1 = (me.columnWidths = []);
                    var columnHeights_1 = (me.columnHeights = []);
                    var totalWidth_1 = labelOpts.padding;
                    var currentColWidth_1 = 0;
                    var currentColHeight_1 = 0;
                    var columnIndex_1 = 0;
                    helpers.each(me.legendItems, function (legendItem, i) {
                        var itemWidth;
                        var height;
                        if (helpers.isArray(legendItem.text)) {
                            itemWidth = getMaxLineWidth(legendItem.text);
                            height = fontSize * legendItem.text.length;
                        }
                        else {
                            itemWidth = ctx.measureText(legendItem.text).width;
                            height = fontSize;
                        }
                        itemWidth += getBoxWidth(labelOpts, fontSize) + fontSize / 2;
                        // If too tall, go to new column
                        if (currentColHeight_1 + fontSize + 2 * vPadding_1 > minSize.height) {
                            totalWidth_1 += currentColWidth_1 + labelOpts.padding;
                            columnWidths_1.push(currentColWidth_1); // previous column width
                            columnHeights_1.push(currentColHeight_1);
                            currentColWidth_1 = 0;
                            currentColHeight_1 = 0;
                            columnIndex_1++;
                        }
                        legendItem.lineOrColumnIndex = columnIndex_1;
                        // Get max width
                        currentColWidth_1 = Math.max(currentColWidth_1, itemWidth);
                        currentColHeight_1 += height + vPadding_1;
                        // Store the hitbox width and height here. Final position will be updated in `draw`
                        hitboxes[i] = {
                            left: 0,
                            top: 0,
                            width: itemWidth,
                            height: height,
                        };
                    });
                    totalWidth_1 += currentColWidth_1;
                    columnWidths_1.push(currentColWidth_1);
                    columnHeights_1.push(currentColHeight_1);
                    minSize.width += totalWidth_1;
                }
            }
            me.width = minSize.width;
            me.height = minSize.height;
        }
        function draw() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var globalDefaults = defaults.global;
            var defaultColor = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me.height;
            var columnHeights = me.columnHeights;
            var columnWidths = me.columnWidths;
            var legendWidth = me.width;
            var lineWidths = me.lineWidths;
            var lineHeights = me.lineHeights;
            if (opts.display) {
                var ctx_1 = me.ctx;
                var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);
                var labelFont = helpers.options._parseFont(labelOpts);
                var fontSize_1 = labelFont.size;
                var cursor_1;
                // Canvas setup
                ctx_1.textAlign = "left";
                ctx_1.textBaseline = "middle";
                ctx_1.lineWidth = 0.5;
                ctx_1.strokeStyle = fontColor; // for strikethrough effect
                ctx_1.fillStyle = fontColor; // render in correct colour
                ctx_1.font = labelFont.string;
                var boxWidth_1 = getBoxWidth(labelOpts, fontSize_1);
                var hitboxes_1 = me.legendHitBoxes;
                // current position
                var drawLegendBox_1 = function (x, y, legendItem) {
                    if (isNaN(boxWidth_1) || boxWidth_1 <= 0) {
                        return;
                    }
                    // Set the ctx for the box
                    ctx_1.save();
                    var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
                    ctx_1.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
                    ctx_1.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
                    ctx_1.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                    ctx_1.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
                    ctx_1.lineWidth = lineWidth;
                    ctx_1.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
                    if (ctx_1.setLineDash) {
                        // IE 9 and 10 do not support line dash
                        ctx_1.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
                    }
                    if (opts.labels && opts.labels.usePointStyle) {
                        // Recalculate x and y for drawPoint() because its expecting
                        // x and y to be center of figure (instead of top left)
                        var radius = (boxWidth_1 * Math.SQRT2) / 2;
                        var centerX = x + boxWidth_1 / 2;
                        var centerY = y + fontSize_1 / 2;
                        // Draw pointStyle as legend symbol
                        helpers.canvas.drawPoint(ctx_1, legendItem.pointStyle, radius, centerX, centerY);
                    }
                    else {
                        // Draw box as legend symbol
                        if (lineWidth !== 0) {
                            ctx_1.strokeRect(x, y, boxWidth_1, fontSize_1);
                        }
                        ctx_1.fillRect(x, y, boxWidth_1, fontSize_1);
                    }
                    ctx_1.restore();
                };
                var drawStrikeThrough_1 = function (x, y, w) {
                    ctx_1.beginPath();
                    ctx_1.lineWidth = 2;
                    ctx_1.moveTo(x, y);
                    ctx_1.lineTo(x + w, y);
                    ctx_1.stroke();
                };
                var drawCrossOver_1 = function (x, y, w, h) {
                    ctx_1.beginPath();
                    ctx_1.lineWidth = 2;
                    ctx_1.moveTo(x, y);
                    ctx_1.lineTo(x + w, y + h);
                    ctx_1.moveTo(x, y + h);
                    ctx_1.lineTo(x + w, y);
                    ctx_1.stroke();
                };
                var fillText_1 = function (x, y, legendItem, textWidth) {
                    var halfFontSize = fontSize_1 / 2;
                    var xLeft = boxWidth_1 + halfFontSize + x;
                    var yMiddle = y + halfFontSize;
                    if (helpers.isArray(legendItem.text)) {
                        helpers.each(legendItem.text, function (textLine, index) {
                            var lineOffset = index * fontSize_1;
                            ctx_1.fillText(textLine, xLeft, yMiddle + lineOffset);
                        });
                    }
                    else {
                        ctx_1.fillText(legendItem.text, xLeft, yMiddle);
                    }
                    if (legendItem.hidden) {
                        if (helpers.isArray(legendItem.text)) {
                            drawCrossOver_1(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize_1 - 1));
                        }
                        else {
                            drawStrikeThrough_1(xLeft, yMiddle, textWidth);
                        }
                    }
                };
                var alignmentOffset_1 = function (dimension, blockSize) {
                    switch (opts.align) {
                        case "start":
                            return labelOpts.padding;
                        case "end":
                            return dimension - blockSize;
                        default:
                            // center
                            return (dimension - blockSize + labelOpts.padding) / 2;
                    }
                };
                // Horizontal
                var isHorizontal_1 = me.isHorizontal();
                if (isHorizontal_1) {
                    cursor_1 = {
                        x: me.left + alignmentOffset_1(legendWidth, lineWidths[0]),
                        y: me.top + labelOpts.padding,
                        line: 0,
                    };
                }
                else {
                    cursor_1 = {
                        x: me.left + labelOpts.padding,
                        y: me.top + alignmentOffset_1(legendHeight, columnHeights[0]),
                        line: 0,
                    };
                }
                helpers.each(me.legendItems, function (legendItem, i) {
                    var textWidth, height, boxTopOffset;
                    if (legendItem.lineOrColumnIndex > cursor_1.line) {
                        if (isHorizontal_1) {
                            cursor_1.y += lineHeights[cursor_1.line];
                            cursor_1.line = legendItem.lineOrColumnIndex;
                            cursor_1.x =
                                me.left + alignmentOffset_1(legendWidth, lineWidths[cursor_1.line]);
                        }
                        else {
                            cursor_1.x += columnWidths[cursor_1.line] + labelOpts.padding;
                            cursor_1.line = legendItem.lineOrColumnIndex;
                            cursor_1.y =
                                me.top +
                                    alignmentOffset_1(legendHeight, columnHeights[cursor_1.line]);
                        }
                    }
                    if (helpers.isArray(legendItem.text)) {
                        textWidth = legendItem.text
                            .map(function (textLine) {
                            return ctx_1.measureText(textLine).width;
                        })
                            .reduce(function (acc, v) {
                            return v > acc ? v : acc;
                        }, 0);
                        boxTopOffset = (fontSize_1 / 2) * (legendItem.text.length - 1);
                        height = fontSize_1 * legendItem.text.length;
                    }
                    else {
                        textWidth = ctx_1.measureText(legendItem.text).width;
                        boxTopOffset = 0;
                        height = fontSize_1;
                    }
                    var width = boxWidth_1 + fontSize_1 / 2 + textWidth;
                    var x = cursor_1.x;
                    var y = cursor_1.y;
                    var topOffset = isHorizontal_1
                        ? Math.trunc((lineHeights[cursor_1.line] - hitboxes_1[i].height) / 2)
                        : 0;
                    drawLegendBox_1(x, y + boxTopOffset + topOffset, legendItem);
                    hitboxes_1[i].left = x;
                    hitboxes_1[i].top = y;
                    // Fill the actual label
                    fillText_1(x, y + topOffset, legendItem, textWidth);
                    if (isHorizontal_1) {
                        cursor_1.x += width + labelOpts.padding;
                    }
                    else {
                        cursor_1.y += height + labelOpts.padding;
                    }
                });
            }
        }
    }

    function monkeyPatchChartJsTooltip() {
        if (typeof Chart === "undefined") {
            console.log("Chart not defined");
            return;
        }
        Chart.Tooltip.prototype.drawBody = drawBody;
        var helpers = Chart.helpers;
        function getAlignedX(vm, align) {
            return align === "center"
                ? vm.x + vm.width / 2
                : align === "right"
                    ? vm.x + vm.width - vm.xPadding
                    : vm.x + vm.xPadding;
        }
        function drawBody(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var labelColors = vm.labelColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var textColor;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "top";
            ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlign);
            // Before Body
            var fillLineOfText = function (line) {
                ctx.fillText(line, pt.x + xLinePadding, pt.y);
                pt.y += bodyFontSize + bodySpacing;
            };
            // Before body lines
            ctx.fillStyle = vm.bodyFontColor;
            helpers.each(vm.beforeBody, fillLineOfText);
            xLinePadding =
                drawColorBoxes && bodyAlign !== "right"
                    ? bodyAlign === "center"
                        ? bodyFontSize / 2 + 1
                        : bodyFontSize + 2
                    : 0;
            // Draw body lines now
            helpers.each(body, function (bodyItem, i) {
                textColor = vm.labelTextColors[i];
                ctx.fillStyle = textColor;
                helpers.each(bodyItem.before, fillLineOfText);
                // Draw Legend-like boxes if needed
                if (drawColorBoxes) {
                    // Fill a white rect so that colours merge nicely if the opacity is < 1
                    ctx.fillStyle = vm.legendColorBackground;
                    ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);
                    // Border
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = labelColors[i].borderColor;
                    ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);
                    // Inner square
                    ctx.fillStyle = labelColors[i].backgroundColor;
                    ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                    ctx.fillStyle = textColor;
                }
                helpers.each(bodyItem.lines, fillLineOfText);
                helpers.each(bodyItem.after, fillLineOfText);
            });
            // Reset back to 0 for after body
            xLinePadding = 0;
            // After body lines
            helpers.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing; // Remove last body spacing
        }
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BaseChartDirective = BaseChartDirective;
    exports.ChartsModule = ChartsModule;
    exports.ThemeService = ThemeService;
    exports.defaultColors = defaultColors;
    exports.monkeyPatchChartJsLegend = monkeyPatchChartJsLegend;
    exports.monkeyPatchChartJsTooltip = monkeyPatchChartJsTooltip;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=rinminase-ng-charts.umd.js.map
