{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../../src/lib/default-colors.ts","../../src/lib/get-colors.ts","../../src/lib/base-chart.directive.ts","../../src/lib/theme.service.ts","../../src/lib/charts.module.ts","../../src/lib/monkey-patch-chart-js-legend.ts","../../src/lib/monkey-patch-chart-js-tooltip.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","defaultColors","getColors","chartType","index","count","formatPieColors","generateColors","backgroundColor","colors","map","color","rgba","borderColor","hoverBackgroundColor","hoverBorderColor","pointBackgroundColor","pointBorderColor","pointHoverBackgroundColor","pointHoverBorderColor","formatLineColor","generateColor","formatBarColor","Error","colour","alpha","concat","join","getRandomInt","min","max","Math","floor","random","getRandomColor","colorsArr","Array","UpdateType","ThemeService","this","pColorschemesOptions","colorschemesOptions","BehaviorSubject","prototype","setColorschemesOptions","options","getColorschemesOptions","Injectable","args","providedIn","BaseChartDirective","element","themeService","chartClick","EventEmitter","chartHover","old","dataExists","dataLength","datasetsExists","datasetsLength","datasetsDataObjects","datasetsDataLengths","colorsExists","labelsExist","labels","legendExists","legend","subs","registerPlugin","plugin","chartJs.Chart","plugins","register","unregisterPlugin","unregister","ngOnInit","_this","ctx","nativeElement","getContext","refresh","subscribe","themeChanged","ngDoCheck","chart","updateRequired","Default","wantUpdate","x","data","propagateDataToDatasets","Update","length","datasets","filter","updateColors","colorsEqual","copyColor","labelsEqual","copyLabel","Refresh","position","update","a","isArray","arguments","__spread","b","borderWidth","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderWidth","pointRadius","pointHoverRadius","pointHitRadius","pointHoverBorderWidth","pointStyle","hoverBorderWidth","forEach","elm","assign","ngOnChanges","changes","hasOwnProperty","currentValue","propagateDatasetsToData","config","display","generateLegend","ngOnDestroy","destroy","unsubscribe","duration","hideDataset","hidden","getDatasetMeta","isDatasetHidden","toBase64Image","getChartConfiguration","getDatasets","hover","onHover","event","active","emit","onClick","mergedOptions","smartMerge","type","getChartBuilder","chartConfig","overrides","level","cloneDeep","keys","key","arrayElements","isMultiLineLabel","label","joinLabel","newDataValues","isMultiDataSet","dataset","splice","Directive","selector","exportAs","ElementRef","Input","Output","NgModule","declarations","imports","exports","Chart","getAll","p","id","_element","fit","me","opts","labelOpts","labelFont","helpers","_parseFont","fontSize","size","hitboxes","legendHitBoxes","minSize","isHorizontal","width","maxWidth","height","maxHeight","getMaxLineWidth","textLines","textLine","measureText","reduce","acc","v","font","string","lineWidths_1","lineWidths","lineHeights_1","lineHeights","currentLineHeight_1","lineIndex_1","textAlign","textBaseline","each","legendItems","legendItem","text","padding","getBoxWidth","lineOrColumnIndex","left","top","vPadding_1","columnWidths_1","columnWidths","columnHeights_1","columnHeights","totalWidth_1","currentColWidth_1","currentColHeight_1","columnIndex_1","itemWidth","draw","globalDefaults","defaults","global","defaultColor","lineDefault","elements","line","legendHeight","legendWidth","cursor_1","ctx_1","fontColor","valueOrDefault","defaultFontColor","fontSize_1","lineWidth","strokeStyle","fillStyle","boxWidth_1","hitboxes_1","fillText_1","y","textWidth","halfFontSize","xLeft","yMiddle","lineOffset","fillText","w","h","beginPath","moveTo","lineTo","stroke","drawCrossOver_1","drawStrikeThrough_1","alignmentOffset_1","dimension","blockSize","align","isHorizontal_1","boxTopOffset","topOffset","trunc","isNaN","save","lineCap","lineDashOffset","lineJoin","setLineDash","lineDash","usePointStyle","radius","SQRT2","centerX","centerY","canvas","drawPoint","strokeRect","fillRect","restore","drawLegendBox_1","console","log","boxWidth","Tooltip","drawBody","pt","vm","textColor","bodyFontSize","bodySpacing","bodyAlign","_bodyAlign","body","drawColorBoxes","displayColors","labelColors","xLinePadding","colorX","getAlignedX","fontString","_bodyFontStyle","_bodyFontFamily","fillLineOfText","bodyFontColor","beforeBody","bodyItem","labelTextColors","before","legendColorBackground","lines","after","afterBody","xPadding"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export const defaultColors: Array<number[]> = [\n  [255, 99, 132],\n  [54, 162, 235],\n  [255, 206, 86],\n  [231, 233, 237],\n  [75, 192, 192],\n  [151, 187, 205],\n  [220, 220, 220],\n  [247, 70, 74],\n  [70, 191, 189],\n  [253, 180, 92],\n  [148, 159, 177],\n  [77, 83, 96],\n];\n","import { DatasetColor } from \"./color\";\nimport { Colors } from \"./colors\";\nimport { defaultColors } from \"./default-colors\";\n\n/**\n * Generate colors by chart type\n */\nexport function getColors(\n  chartType: string,\n  index: number,\n  count: number\n): DatasetColor {\n  if (chartType === \"pie\" || chartType === \"doughnut\") {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === \"polarArea\") {\n    return formatPolarAreaColors(generateColors(count));\n  }\n\n  if (chartType === \"line\" || chartType === \"radar\") {\n    return formatLineColor(generateColor(index));\n  }\n\n  if (chartType === \"bar\" || chartType === \"horizontalBar\") {\n    return formatBarColor(generateColor(index));\n  }\n\n  if (chartType === \"bubble\") {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === \"scatter\") {\n    return formatPieColors(generateColors(count));\n  }\n\n  throw new Error(`getColors - Unsupported chart type ${chartType}`);\n}\n\nfunction rgba(colour: Array<number>, alpha: number): string {\n  return \"rgba(\" + colour.concat(alpha).join(\",\") + \")\";\n}\n\nfunction getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction formatLineColor(colors: Array<number>): DatasetColor {\n  return {\n    backgroundColor: rgba(colors, 0.4),\n    borderColor: rgba(colors, 1),\n    pointBackgroundColor: rgba(colors, 1),\n    pointBorderColor: \"#fff\",\n    pointHoverBackgroundColor: \"#fff\",\n    pointHoverBorderColor: rgba(colors, 0.8),\n  };\n}\n\nfunction formatBarColor(colors: Array<number>): DatasetColor {\n  return {\n    backgroundColor: rgba(colors, 0.6),\n    borderColor: rgba(colors, 1),\n    hoverBackgroundColor: rgba(colors, 0.8),\n    hoverBorderColor: rgba(colors, 1),\n  };\n}\n\nfunction formatPieColors(colors: Array<number[]>): Colors {\n  return {\n    backgroundColor: colors.map((color: number[]) => rgba(color, 0.6)),\n    borderColor: colors.map(() => \"#fff\"),\n    pointBackgroundColor: colors.map((color: number[]) => rgba(color, 1)),\n    pointBorderColor: colors.map(() => \"#fff\"),\n    pointHoverBackgroundColor: colors.map((color: number[]) => rgba(color, 1)),\n    pointHoverBorderColor: colors.map((color: number[]) => rgba(color, 1)),\n  };\n}\n\nfunction formatPolarAreaColors(colors: Array<number[]>): DatasetColor {\n  return {\n    backgroundColor: colors.map((color: number[]) => rgba(color, 0.6)),\n    borderColor: colors.map((color: number[]) => rgba(color, 1)),\n    hoverBackgroundColor: colors.map((color: number[]) => rgba(color, 0.8)),\n    hoverBorderColor: colors.map((color: number[]) => rgba(color, 1)),\n  };\n}\n\nfunction getRandomColor(): number[] {\n  return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n\n/**\n * Generate colors for line|bar charts\n */\nfunction generateColor(index: number): number[] {\n  return defaultColors[index] || getRandomColor();\n}\n\n/**\n * Generate colors for pie|doughnut charts\n */\nfunction generateColors(count: number): Array<number[]> {\n  const colorsArr: Array<number[]> = new Array(count);\n  for (let i = 0; i < count; i++) {\n    colorsArr[i] = defaultColors[i] || getRandomColor();\n  }\n  return colorsArr;\n}\n","import {\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from \"@angular/core\";\nimport * as chartJs from \"chart.js\";\nimport { getColors } from \"./get-colors\";\nimport { DatasetColor } from \"./color\";\nimport { ThemeService } from \"./theme.service\";\nimport { Subscription } from \"rxjs\";\nimport { cloneDeep } from \"lodash-es\";\n\nexport type SingleDataSet = number[] | chartJs.ChartPoint[];\nexport type MultiDataSet = (number[] | chartJs.ChartPoint[])[];\nexport type SingleOrMultiDataSet = SingleDataSet | MultiDataSet;\n\nexport type PluginServiceGlobalRegistrationAndOptions = chartJs.PluginServiceGlobalRegistration &\n  chartJs.PluginServiceRegistrationOptions;\nexport type SingleLineLabel = string;\nexport type MultiLineLabel = string[];\n\nexport type ChartLabel = SingleLineLabel | MultiLineLabel;\nexport type ChartColor = DatasetColor[];\nexport type ChartType = chartJs.ChartType;\nexport type ChartDataset = chartJs.ChartDataSets;\nexport type ChartDatasets = chartJs.ChartDataSets[];\nexport type ChartOptions = chartJs.ChartOptions;\n\ninterface OldState {\n  dataExists: boolean;\n  dataLength: number;\n  datasetsExists: boolean;\n  datasetsLength: number;\n  datasetsDataObjects: any[];\n  datasetsDataLengths: number[];\n  colorsExists: boolean;\n  colors: DatasetColor[];\n  labelsExist: boolean;\n  labels: ChartLabel[];\n  legendExists: boolean;\n  legend: {\n    position?: string;\n  };\n}\n\nenum UpdateType {\n  Default,\n  Update,\n  Refresh,\n}\n\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: \"canvas[baseChart]\",\n  exportAs: \"base-chart\",\n})\nexport class BaseChartDirective\n  implements OnDestroy, OnChanges, OnInit, OnDestroy, DoCheck {\n  @Input() public data: SingleOrMultiDataSet;\n  @Input() public datasets: ChartDatasets;\n  @Input() public labels: ChartLabel[];\n  @Input() public options: ChartOptions = {};\n  @Input() public chartType: ChartType;\n  @Input() public colors: DatasetColor[];\n  @Input() public legend: boolean;\n  @Input() public plugins: PluginServiceGlobalRegistrationAndOptions[];\n\n  @Output() public chartClick: EventEmitter<{\n    event?: MouseEvent;\n    active?: {}[];\n  }> = new EventEmitter();\n  @Output() public chartHover: EventEmitter<{\n    event: MouseEvent;\n    active: {}[];\n  }> = new EventEmitter();\n\n  public ctx: string;\n  public chart: Chart;\n\n  private old: OldState = {\n    dataExists: false,\n    dataLength: 0,\n    datasetsExists: false,\n    datasetsLength: 0,\n    datasetsDataObjects: [],\n    datasetsDataLengths: [],\n    colorsExists: false,\n    colors: [],\n    labelsExist: false,\n    labels: [],\n    legendExists: false,\n    legend: {},\n  };\n\n  private subs: Subscription[] = [];\n\n  /**\n   * Register a plugin.\n   */\n  public static registerPlugin(\n    plugin: PluginServiceGlobalRegistrationAndOptions\n  ) {\n    chartJs.Chart.plugins.register(plugin);\n  }\n\n  public static unregisterPlugin(\n    plugin: PluginServiceGlobalRegistrationAndOptions\n  ) {\n    chartJs.Chart.plugins.unregister(plugin);\n  }\n\n  public constructor(\n    private element: ElementRef,\n    private themeService: ThemeService\n  ) {}\n\n  public ngOnInit() {\n    this.ctx = this.element.nativeElement.getContext(\"2d\");\n    this.refresh();\n    this.subs.push(\n      this.themeService.colorschemesOptions.subscribe(() => this.themeChanged())\n    );\n  }\n\n  private themeChanged() {\n    this.refresh();\n  }\n\n  ngDoCheck(): void {\n    if (!this.chart) {\n      return;\n    }\n    let updateRequired = UpdateType.Default;\n    const wantUpdate = (x: UpdateType) => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n\n    if (!!this.data !== this.old.dataExists) {\n      this.propagateDataToDatasets(this.data);\n\n      this.old.dataExists = !!this.data;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.data && this.data.length !== this.old.dataLength) {\n      this.old.dataLength = (this.data && this.data.length) || 0;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.datasets !== this.old.datasetsExists) {\n      this.old.datasetsExists = !!this.datasets;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\n      this.old.datasetsLength = (this.datasets && this.datasets.length) || 0;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (\n      this.datasets &&\n      this.datasets.filter((x, i) => x.data !== this.old.datasetsDataObjects[i])\n        .length\n    ) {\n      this.old.datasetsDataObjects = this.datasets.map((x) => x.data);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (\n      this.datasets &&\n      this.datasets.filter(\n        (x, i) => x.data.length !== this.old.datasetsDataLengths[i]\n      ).length\n    ) {\n      this.old.datasetsDataLengths = this.datasets.map((x) => x.data.length);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.colors !== this.old.colorsExists) {\n      this.old.colorsExists = !!this.colors;\n\n      this.updateColors();\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    // This smells of inefficiency, might need to revisit this\n    if (\n      this.colors &&\n      this.colors.filter((x, i) => !this.colorsEqual(x, this.old.colors[i]))\n        .length\n    ) {\n      this.old.colors = this.colors.map((x) => this.copyColor(x));\n\n      this.updateColors();\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.labels !== this.old.labelsExist) {\n      this.old.labelsExist = !!this.labels;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (\n      this.labels &&\n      this.labels.filter((x, i) => !this.labelsEqual(x, this.old.labels[i]))\n        .length\n    ) {\n      this.old.labels = this.labels.map((x) => this.copyLabel(x));\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.options.legend !== this.old.legendExists) {\n      this.old.legendExists = !!this.options.legend;\n\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    if (\n      this.options.legend &&\n      this.options.legend.position !== this.old.legend.position\n    ) {\n      this.old.legend.position = this.options.legend.position;\n\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    switch (updateRequired as UpdateType) {\n      case UpdateType.Default:\n        break;\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n        this.refresh();\n        break;\n    }\n  }\n\n  copyLabel(a: ChartLabel): ChartLabel {\n    if (Array.isArray(a)) {\n      return [...a];\n    }\n    return a;\n  }\n\n  labelsEqual(a: ChartLabel, b: ChartLabel) {\n    return (\n      true &&\n      Array.isArray(a) === Array.isArray(b) &&\n      (Array.isArray(a) || a === b) &&\n      (!Array.isArray(a) || a.length === b.length) &&\n      (!Array.isArray(a) || a.filter((x, i) => x !== b[i]).length === 0)\n    );\n  }\n\n  copyColor(a: DatasetColor): DatasetColor {\n    const rc: DatasetColor = {\n      backgroundColor: a.backgroundColor,\n      borderWidth: a.borderWidth,\n      borderColor: a.borderColor,\n      borderCapStyle: a.borderCapStyle,\n      borderDash: a.borderDash,\n      borderDashOffset: a.borderDashOffset,\n      borderJoinStyle: a.borderJoinStyle,\n      pointBorderColor: a.pointBorderColor,\n      pointBackgroundColor: a.pointBackgroundColor,\n      pointBorderWidth: a.pointBorderWidth,\n      pointRadius: a.pointRadius,\n      pointHoverRadius: a.pointHoverRadius,\n      pointHitRadius: a.pointHitRadius,\n      pointHoverBackgroundColor: a.pointHoverBackgroundColor,\n      pointHoverBorderColor: a.pointHoverBorderColor,\n      pointHoverBorderWidth: a.pointHoverBorderWidth,\n      pointStyle: a.pointStyle,\n      hoverBackgroundColor: a.hoverBackgroundColor,\n      hoverBorderColor: a.hoverBorderColor,\n      hoverBorderWidth: a.hoverBorderWidth,\n    };\n\n    return rc;\n  }\n\n  colorsEqual(a: DatasetColor, b: DatasetColor) {\n    if (!a !== !b) {\n      return false;\n    }\n    return (\n      !a ||\n      (true &&\n        a.backgroundColor === b.backgroundColor &&\n        a.borderWidth === b.borderWidth &&\n        a.borderColor === b.borderColor &&\n        a.borderCapStyle === b.borderCapStyle &&\n        a.borderDash === b.borderDash &&\n        a.borderDashOffset === b.borderDashOffset &&\n        a.borderJoinStyle === b.borderJoinStyle &&\n        a.pointBorderColor === b.pointBorderColor &&\n        a.pointBackgroundColor === b.pointBackgroundColor &&\n        a.pointBorderWidth === b.pointBorderWidth &&\n        a.pointRadius === b.pointRadius &&\n        a.pointHoverRadius === b.pointHoverRadius &&\n        a.pointHitRadius === b.pointHitRadius &&\n        a.pointHoverBackgroundColor === b.pointHoverBackgroundColor &&\n        a.pointHoverBorderColor === b.pointHoverBorderColor &&\n        a.pointHoverBorderWidth === b.pointHoverBorderWidth &&\n        a.pointStyle === b.pointStyle &&\n        a.hoverBackgroundColor === b.hoverBackgroundColor &&\n        a.hoverBorderColor === b.hoverBorderColor &&\n        a.hoverBorderWidth === b.hoverBorderWidth)\n    );\n  }\n\n  updateColors() {\n    this.datasets.forEach((elm, index) => {\n      if (this.colors && this.colors[index]) {\n        Object.assign(elm, this.colors[index]);\n      } else {\n        Object.assign(elm, getColors(this.chartType, index, elm.data.length), {\n          ...elm,\n        });\n      }\n    });\n  }\n\n  public ngOnChanges(changes: SimpleChanges) {\n    let updateRequired = UpdateType.Default;\n    const wantUpdate = (x: UpdateType) => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n\n    // Check if the changes are in the data or datasets or labels or legend\n\n    if (changes.hasOwnProperty(\"data\") && changes.data.currentValue) {\n      this.propagateDataToDatasets(changes.data.currentValue);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty(\"datasets\") && changes.datasets.currentValue) {\n      this.propagateDatasetsToData(changes.datasets.currentValue);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty(\"labels\")) {\n      if (this.chart) {\n        this.chart.data.labels = changes.labels.currentValue;\n      }\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty(\"legend\")) {\n      if (this.chart) {\n        this.chart.config.options.legend.display = changes.legend.currentValue;\n        this.chart.generateLegend();\n      }\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty(\"options\")) {\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    switch (updateRequired as UpdateType) {\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n      case UpdateType.Default:\n        this.refresh();\n        break;\n    }\n  }\n\n  public ngOnDestroy() {\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    this.subs.forEach((x) => x.unsubscribe());\n  }\n\n  public update(duration?: any) {\n    if (this.chart) {\n      return this.chart.update(duration);\n    }\n    return null;\n  }\n\n  public hideDataset(index: number, hidden: boolean) {\n    this.chart.getDatasetMeta(index).hidden = hidden;\n    this.chart.update();\n  }\n\n  public isDatasetHidden(index: number): boolean {\n    return this.chart.getDatasetMeta(index).hidden;\n  }\n\n  public toBase64Image(): string {\n    return this.chart.toBase64Image();\n  }\n\n  public getChartConfiguration(): chartJs.ChartConfiguration {\n    const datasets = this.getDatasets();\n\n    const options = Object.assign({}, this.options);\n    if (this.legend === false) {\n      options.legend = { display: false };\n    }\n    // hook for onHover and onClick events\n    options.hover = options.hover || {};\n    if (!options.hover.onHover) {\n      options.hover.onHover = (event: MouseEvent, active: {}[]) => {\n        if (active && !active.length) {\n          return;\n        }\n        this.chartHover.emit({ event, active });\n      };\n    }\n\n    if (!options.onClick) {\n      options.onClick = (event?: MouseEvent, active?: {}[]) => {\n        this.chartClick.emit({ event, active });\n      };\n    }\n\n    const mergedOptions = this.smartMerge(\n      options,\n      this.themeService.getColorschemesOptions()\n    );\n\n    const chartConfig: chartJs.ChartConfiguration = {\n      type: this.chartType,\n      data: {\n        labels: this.labels || [],\n        datasets,\n      },\n      plugins: this.plugins,\n      options: mergedOptions,\n    };\n\n    return chartConfig;\n  }\n\n  public getChartBuilder(ctx: string /*, data:any[], options:any*/): Chart {\n    const chartConfig = this.getChartConfiguration();\n    return new chartJs.Chart(ctx, chartConfig);\n  }\n\n  smartMerge(options: any, overrides: any, level: number = 0): any {\n    if (level === 0) {\n      options = cloneDeep(options);\n    }\n    const keysToUpdate = Object.keys(overrides);\n    keysToUpdate.forEach((key) => {\n      if (Array.isArray(overrides[key])) {\n        const arrayElements = options[key];\n        if (arrayElements) {\n          arrayElements.forEach((r) => {\n            this.smartMerge(r, overrides[key][0], level + 1);\n          });\n        }\n      } else if (typeof overrides[key] === \"object\") {\n        if (!(key in options)) {\n          options[key] = {};\n        }\n        this.smartMerge(options[key], overrides[key], level + 1);\n      } else {\n        options[key] = overrides[key];\n      }\n    });\n    if (level === 0) {\n      return options;\n    }\n  }\n\n  private isMultiLineLabel(label: ChartLabel): label is MultiLineLabel {\n    return Array.isArray(label);\n  }\n\n  private joinLabel(label: ChartLabel): string {\n    if (!label) {\n      return null;\n    }\n    if (this.isMultiLineLabel(label)) {\n      return label.join(\" \");\n    } else {\n      return label;\n    }\n  }\n\n  private propagateDatasetsToData(datasets: chartJs.ChartDataSets[]) {\n    this.data = this.datasets.map((r) => r.data) as MultiDataSet;\n    if (this.chart) {\n      this.chart.data.datasets = datasets;\n    }\n    this.updateColors();\n  }\n\n  private propagateDataToDatasets(newDataValues: SingleOrMultiDataSet): void {\n    if (this.isMultiDataSet(newDataValues)) {\n      if (this.datasets && newDataValues.length === this.datasets.length) {\n        this.datasets.forEach((dataset, i: number) => {\n          dataset.data = newDataValues[i];\n        });\n      } else {\n        this.datasets = newDataValues.map((data: number[], index: number) => {\n          return {\n            data,\n            label: this.joinLabel(this.labels[index]) || `Label ${index}`,\n          };\n        });\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      }\n    } else {\n      if (!this.datasets) {\n        this.datasets = [{ data: newDataValues }];\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      } else {\n        this.datasets[0].data = newDataValues;\n        this.datasets.splice(1); // Remove all elements but the first\n      }\n    }\n    this.updateColors();\n  }\n\n  private isMultiDataSet(data: SingleOrMultiDataSet): data is MultiDataSet {\n    return Array.isArray(data[0]);\n  }\n\n  private getDatasets() {\n    if (!this.datasets && !this.data) {\n      throw new Error(\n        `ng-charts configuration error, data or datasets field are required to render chart ${this.chartType}`\n      );\n    }\n\n    // If `datasets` is defined, use it over the `data` property.\n    if (this.datasets) {\n      this.propagateDatasetsToData(this.datasets);\n      return this.datasets;\n    }\n\n    if (this.data) {\n      this.propagateDataToDatasets(this.data);\n      return this.datasets;\n    }\n\n    return null;\n  }\n\n  private refresh() {\n    // if (this.options && this.options.responsive) {\n    //   setTimeout(() => this.refresh(), 50);\n    // }\n\n    // todo: remove this line, it is producing flickering\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    if (this.ctx) {\n      this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\n    }\n  }\n}\n","import { Injectable } from \"@angular/core\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { ChartOptions } from \"chart.js\";\n\n@Injectable({ providedIn: \"root\" })\nexport class ThemeService {\n  private pColorschemesOptions: ChartOptions = {};\n  public colorschemesOptions = new BehaviorSubject<ChartOptions>({});\n\n  constructor() {}\n\n  setColorschemesOptions(options: ChartOptions) {\n    this.pColorschemesOptions = options;\n    this.colorschemesOptions.next(options);\n  }\n\n  getColorschemesOptions() {\n    return this.pColorschemesOptions;\n  }\n}\n","import { NgModule } from \"@angular/core\";\nimport { BaseChartDirective } from \"./base-chart.directive\";\n\n@NgModule({\n  declarations: [BaseChartDirective],\n  imports: [],\n  exports: [BaseChartDirective],\n})\nexport class ChartsModule {}\n","declare class Chart {\n  static readonly Chart: typeof Chart;\n  static readonly Tooltip: any;\n  static readonly helpers: any;\n  static readonly defaults: any;\n  static readonly plugins: any;\n}\n\nexport function monkeyPatchChartJsLegend() {\n  if (typeof Chart === \"undefined\") {\n    console.log(\"Chart not defined\");\n    return;\n  }\n  const plugins = Chart.plugins.getAll();\n  const legend = plugins.filter((p) => p.id === \"legend\")[0];\n  legend._element.prototype.fit = fit;\n  legend._element.prototype.draw = draw;\n\n  const helpers = Chart.helpers;\n  const defaults = Chart.defaults;\n  const valueOrDefault = helpers.valueOrDefault;\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize\n      ? fontSize\n      : labelOpts.boxWidth;\n  }\n\n  function fit() {\n    let me = this;\n    let opts = me.options;\n    let labelOpts = opts.labels;\n    let display = opts.display;\n\n    let ctx = me.ctx;\n\n    let labelFont = helpers.options._parseFont(labelOpts);\n    let fontSize = labelFont.size;\n\n    // Reset hit boxes\n    let hitboxes = (me.legendHitBoxes = []);\n\n    let minSize = me.minSize;\n    let isHorizontal = me.isHorizontal();\n\n    if (isHorizontal) {\n      minSize.width = me.maxWidth; // fill all the width\n      minSize.height = display ? 10 : 0;\n    } else {\n      minSize.width = display ? 10 : 0;\n      minSize.height = me.maxHeight; // fill all the height\n    }\n\n    let getMaxLineWidth = function (textLines) {\n      return textLines\n        .map(function (textLine) {\n          return ctx.measureText(textLine).width;\n        })\n        .reduce(function (acc, v) {\n          return v > acc ? v : acc;\n        }, 0);\n    };\n\n    // Increase sizes here\n    if (display) {\n      ctx.font = labelFont.string;\n\n      if (isHorizontal) {\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n        let lineWidths = (me.lineWidths = [0]);\n        let lineHeights = (me.lineHeights = []);\n        let currentLineHeight = 0;\n        let lineIndex = 0;\n\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"top\";\n\n        helpers.each(me.legendItems, function (legendItem, i) {\n          let width, height;\n\n          if (helpers.isArray(legendItem.text)) {\n            width = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length + labelOpts.padding;\n          } else {\n            width = ctx.measureText(legendItem.text).width;\n            height = fontSize + labelOpts.padding;\n          }\n          width += getBoxWidth(labelOpts, fontSize) + fontSize / 2;\n\n          if (\n            lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding >\n            minSize.width\n          ) {\n            lineHeights.push(currentLineHeight);\n            currentLineHeight = 0;\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n            lineIndex++;\n          }\n\n          legendItem.lineOrColumnIndex = lineIndex;\n\n          if (height > currentLineHeight) {\n            currentLineHeight = height;\n          }\n\n          // Store the hitbox width and height here. Final position will be updated in `draw`\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: height,\n          };\n\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n\n        lineHeights.push(currentLineHeight);\n        minSize.height += lineHeights.reduce(function (acc, v) {\n          return acc + v;\n        }, 0);\n      } else {\n        let vPadding = labelOpts.padding;\n        let columnWidths = (me.columnWidths = []);\n        let columnHeights = (me.columnHeights = []);\n        let totalWidth = labelOpts.padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let columnIndex = 0;\n\n        helpers.each(me.legendItems, function (legendItem, i) {\n          let itemWidth;\n          let height;\n\n          if (helpers.isArray(legendItem.text)) {\n            itemWidth = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length;\n          } else {\n            itemWidth = ctx.measureText(legendItem.text).width;\n            height = fontSize;\n          }\n          itemWidth += getBoxWidth(labelOpts, fontSize) + fontSize / 2;\n\n          // If too tall, go to new column\n          if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n            columnHeights.push(currentColHeight);\n            currentColWidth = 0;\n            currentColHeight = 0;\n            columnIndex++;\n          }\n\n          legendItem.lineOrColumnIndex = columnIndex;\n\n          // Get max width\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += height + vPadding;\n\n          // Store the hitbox width and height here. Final position will be updated in `draw`\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: height,\n          };\n        });\n\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        columnHeights.push(currentColHeight);\n        minSize.width += totalWidth;\n      }\n    }\n\n    me.width = minSize.width;\n    me.height = minSize.height;\n  }\n\n  function draw() {\n    let me = this;\n    let opts = me.options;\n    let labelOpts = opts.labels;\n    let globalDefaults = defaults.global;\n    let defaultColor = globalDefaults.defaultColor;\n    let lineDefault = globalDefaults.elements.line;\n    let legendHeight = me.height;\n    let columnHeights = me.columnHeights;\n    let columnWidths = me.columnWidths;\n    let legendWidth = me.width;\n    let lineWidths = me.lineWidths;\n    let lineHeights = me.lineHeights;\n\n    if (opts.display) {\n      let ctx = me.ctx;\n      let fontColor = valueOrDefault(\n        labelOpts.fontColor,\n        globalDefaults.defaultFontColor\n      );\n      let labelFont = helpers.options._parseFont(labelOpts);\n      let fontSize = labelFont.size;\n      let cursor;\n\n      // Canvas setup\n      ctx.textAlign = \"left\";\n      ctx.textBaseline = \"middle\";\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n      ctx.fillStyle = fontColor; // render in correct colour\n      ctx.font = labelFont.string;\n\n      let boxWidth = getBoxWidth(labelOpts, fontSize);\n      let hitboxes = me.legendHitBoxes;\n\n      // current position\n      let drawLegendBox = function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        }\n\n        // Set the ctx for the box\n        ctx.save();\n\n        let lineWidth = valueOrDefault(\n          legendItem.lineWidth,\n          lineDefault.borderWidth\n        );\n        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n        ctx.lineCap = valueOrDefault(\n          legendItem.lineCap,\n          lineDefault.borderCapStyle\n        );\n        ctx.lineDashOffset = valueOrDefault(\n          legendItem.lineDashOffset,\n          lineDefault.borderDashOffset\n        );\n        ctx.lineJoin = valueOrDefault(\n          legendItem.lineJoin,\n          lineDefault.borderJoinStyle\n        );\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(\n            valueOrDefault(legendItem.lineDash, lineDefault.borderDash)\n          );\n        }\n\n        if (opts.labels && opts.labels.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n          let radius = (boxWidth * Math.SQRT2) / 2;\n          let centerX = x + boxWidth / 2;\n          let centerY = y + fontSize / 2;\n\n          // Draw pointStyle as legend symbol\n          helpers.canvas.drawPoint(\n            ctx,\n            legendItem.pointStyle,\n            radius,\n            centerX,\n            centerY\n          );\n        } else {\n          // Draw box as legend symbol\n          if (lineWidth !== 0) {\n            ctx.strokeRect(x, y, boxWidth, fontSize);\n          }\n          ctx.fillRect(x, y, boxWidth, fontSize);\n        }\n\n        ctx.restore();\n      };\n\n      let drawStrikeThrough = function (x, y, w) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n\n      let drawCrossOver = function (x, y, w, h) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y + h);\n        ctx.moveTo(x, y + h);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n\n      let fillText = function (x, y, legendItem, textWidth) {\n        let halfFontSize = fontSize / 2;\n        let xLeft = boxWidth + halfFontSize + x;\n        let yMiddle = y + halfFontSize;\n\n        if (helpers.isArray(legendItem.text)) {\n          helpers.each(legendItem.text, function (textLine, index) {\n            let lineOffset = index * fontSize;\n            ctx.fillText(textLine, xLeft, yMiddle + lineOffset);\n          });\n        } else {\n          ctx.fillText(legendItem.text, xLeft, yMiddle);\n        }\n\n        if (legendItem.hidden) {\n          if (helpers.isArray(legendItem.text)) {\n            drawCrossOver(\n              xLeft,\n              yMiddle,\n              textWidth,\n              (legendItem.text.length - 1) * (fontSize - 1)\n            );\n          } else {\n            drawStrikeThrough(xLeft, yMiddle, textWidth);\n          }\n        }\n      };\n\n      let alignmentOffset = function (dimension, blockSize) {\n        switch (opts.align) {\n          case \"start\":\n            return labelOpts.padding;\n          case \"end\":\n            return dimension - blockSize;\n          default:\n            // center\n            return (dimension - blockSize + labelOpts.padding) / 2;\n        }\n      };\n\n      // Horizontal\n      let isHorizontal = me.isHorizontal();\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n          y: me.top + labelOpts.padding,\n          line: 0,\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n          line: 0,\n        };\n      }\n\n      helpers.each(me.legendItems, function (legendItem, i) {\n        let textWidth, height, boxTopOffset;\n\n        if (legendItem.lineOrColumnIndex > cursor.line) {\n          if (isHorizontal) {\n            cursor.y += lineHeights[cursor.line];\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.x =\n              me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n          } else {\n            cursor.x += columnWidths[cursor.line] + labelOpts.padding;\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.y =\n              me.top +\n              alignmentOffset(legendHeight, columnHeights[cursor.line]);\n          }\n        }\n\n        if (helpers.isArray(legendItem.text)) {\n          textWidth = legendItem.text\n            .map(function (textLine) {\n              return ctx.measureText(textLine).width;\n            })\n            .reduce(function (acc, v) {\n              return v > acc ? v : acc;\n            }, 0);\n          boxTopOffset = (fontSize / 2) * (legendItem.text.length - 1);\n          height = fontSize * legendItem.text.length;\n        } else {\n          textWidth = ctx.measureText(legendItem.text).width;\n          boxTopOffset = 0;\n          height = fontSize;\n        }\n\n        let width = boxWidth + fontSize / 2 + textWidth;\n        let x = cursor.x;\n        let y = cursor.y;\n\n        let topOffset = isHorizontal\n          ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2)\n          : 0;\n\n        drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);\n\n        hitboxes[i].left = x;\n        hitboxes[i].top = y;\n\n        // Fill the actual label\n        fillText(x, y + topOffset, legendItem, textWidth);\n\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += height + labelOpts.padding;\n        }\n      });\n    }\n  }\n}\n","declare class Chart {\n  static readonly Chart: typeof Chart;\n  static readonly Tooltip: any;\n  static readonly helpers: any;\n  static readonly defaults: any;\n  static readonly plugins: any;\n}\n\nexport function monkeyPatchChartJsTooltip() {\n  if (typeof Chart === \"undefined\") {\n    console.log(\"Chart not defined\");\n    return;\n  }\n  Chart.Tooltip.prototype.drawBody = drawBody;\n  const helpers = Chart.helpers;\n\n  function getAlignedX(vm, align) {\n    return align === \"center\"\n      ? vm.x + vm.width / 2\n      : align === \"right\"\n      ? vm.x + vm.width - vm.xPadding\n      : vm.x + vm.xPadding;\n  }\n\n  function drawBody(pt, vm, ctx) {\n    let bodyFontSize = vm.bodyFontSize;\n    let bodySpacing = vm.bodySpacing;\n    let bodyAlign = vm._bodyAlign;\n    let body = vm.body;\n    let drawColorBoxes = vm.displayColors;\n    let labelColors = vm.labelColors;\n    let xLinePadding = 0;\n    let colorX = drawColorBoxes ? getAlignedX(vm, \"left\") : 0;\n    let textColor;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = \"top\";\n    ctx.font = helpers.fontString(\n      bodyFontSize,\n      vm._bodyFontStyle,\n      vm._bodyFontFamily\n    );\n\n    pt.x = getAlignedX(vm, bodyAlign);\n\n    // Before Body\n    let fillLineOfText = function (line) {\n      ctx.fillText(line, pt.x + xLinePadding, pt.y);\n      pt.y += bodyFontSize + bodySpacing;\n    };\n\n    // Before body lines\n    ctx.fillStyle = vm.bodyFontColor;\n    helpers.each(vm.beforeBody, fillLineOfText);\n\n    xLinePadding =\n      drawColorBoxes && bodyAlign !== \"right\"\n        ? bodyAlign === \"center\"\n          ? bodyFontSize / 2 + 1\n          : bodyFontSize + 2\n        : 0;\n\n    // Draw body lines now\n    helpers.each(body, function (bodyItem, i) {\n      textColor = vm.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      helpers.each(bodyItem.before, fillLineOfText);\n\n      // Draw Legend-like boxes if needed\n      if (drawColorBoxes) {\n        // Fill a white rect so that colours merge nicely if the opacity is < 1\n        ctx.fillStyle = vm.legendColorBackground;\n        ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\n        // Border\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = labelColors[i].borderColor;\n        ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\n        // Inner square\n        ctx.fillStyle = labelColors[i].backgroundColor;\n        ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n        ctx.fillStyle = textColor;\n      }\n\n      helpers.each(bodyItem.lines, fillLineOfText);\n\n      helpers.each(bodyItem.after, fillLineOfText);\n    });\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n\n    // After body lines\n    helpers.each(vm.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n}\n"]}